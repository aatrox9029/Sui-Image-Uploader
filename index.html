<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Sui 圖片分塊上傳</title>
  <style>
    body { font-family: "Segoe UI", "Noto Sans TC", sans-serif; margin: 0; padding: 20px; background: #0f172a; color: #e2e8f0; }
    .card { width: min(100%, 1080px); background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 14px; margin: 0 auto 12px; }
    .topbar { display: flex; justify-content: space-between; align-items: center; gap: 8px; margin-bottom: 8px; }
    .topbar h2 { margin: 0; }
    .topbar-actions { display: flex; gap: 8px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    @media (max-width: 760px) { .row { grid-template-columns: 1fr; } body { padding: 12px; } }
    .input, .btn { width: 100%; box-sizing: border-box; border-radius: 8px; border: 1px solid #334155; padding: 9px; font-size: 13px; }
    .input { background: #0b1222; color: #e2e8f0; }
    .btn { background: #0ea5e9; color: #fff; border: 0; font-weight: 700; cursor: pointer; }
    .btn:disabled { opacity: 0.45; cursor: not-allowed; }
    .btn-ok { background: #10b981; }
    .btn-danger { background: #ef4444; }
    .btn-secondary { background: #475569; }
    .meta { color: #94a3b8; font-size: 12px; margin: 6px 0; word-break: break-all; }
    .console { background: #020617; color: #86efac; border: 1px solid #1d4f3a; border-radius: 8px; padding: 10px; max-height: 220px; overflow-y: auto; white-space: pre-wrap; font-family: Consolas, monospace; font-size: 12px; }
    .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 10px; margin-top: 8px; }
    .item { background: #0b1222; border: 1px solid #334155; border-radius: 10px; padding: 8px; }
    .preview { width: 100%; aspect-ratio: 1; border-radius: 8px; border: 1px solid #223044; background: #020617; display: flex; align-items: center; justify-content: center; color: #94a3b8; font-size: 12px; text-align: center; padding: 6px; overflow: hidden; }
    .preview img { width: 100%; height: 100%; object-fit: cover; }
    #compress-preview { width: min(100%, 500px); height: min(500px, 70vh); margin: 8px auto 0; }
    #compress-preview img { object-fit: contain; cursor: zoom-in; }
    .lightbox { position: fixed; inset: 0; z-index: 9999; background: rgba(2, 6, 23, 0.92); display: flex; align-items: center; justify-content: center; padding: 16px; }
    .lightbox-scroll { max-width: 100%; max-height: 100%; overflow: auto; border: 1px solid #334155; border-radius: 10px; background: #020617; padding: 8px; }
    .lightbox-scroll img { width: auto; height: auto; max-width: none; max-height: none; display: block; cursor: zoom-out; }
    .lightbox-hint { position: fixed; left: 50%; bottom: 14px; transform: translateX(-50%); background: rgba(15, 23, 42, 0.85); border: 1px solid #334155; border-radius: 999px; padding: 8px 14px; font-size: 12px; color: #cbd5e1; pointer-events: none; }
    .actions { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 6px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <section class="card">
    <div class="topbar">
      <h2 id="title-main">Sui 分塊上傳 + 密碼保護</h2>
      <div class="topbar-actions">
        <select id="lang-select" class="input" style="width:20ch; min-width:20ch; max-width:20ch;">
          <option value="zh-Hant">繁體中文</option>
          <option value="zh-Hans">简体中文</option>
          <option value="en">English</option>
          <option value="ja">日本語</option>
          <option value="ko">한국어</option>
        </select>
        <button id="btn-disconnect" class="btn btn-secondary hidden" style="max-width:160px;">斷開錢包</button>
      </div>
    </div>
    <div id="connect-ui" class="row">
      <button id="btn-slush" class="btn">連接 Slush / Sui Wallet</button>
      <button id="btn-okx" class="btn">連接 OKX Wallet</button>
    </div>
    <div id="app-ui" class="hidden">
      <div id="address" class="meta"></div>
      <div id="chain" class="meta"></div>
      <label id="label-package" class="meta">Package ID</label>
      <div class="row">
        <input id="package-id-input" class="input" type="text" />
        <button id="btn-apply-package" class="btn">套用 Package</button>
      </div>
      <label id="label-file" class="meta">圖片檔案</label>
      <input id="file-input" class="input" type="file" accept="image/*" />
      <label id="label-description" class="meta">圖片描述</label>
      <input id="description-input" class="input" type="text" placeholder="例如：旅遊照片" />
      <label class="meta"><input id="password-toggle" type="checkbox" /> <span id="label-password-toggle">啟用密碼保護</span></label>
      <input id="password-input" class="input" type="password" placeholder="至少 8 字元" disabled />
      <label id="label-compress" class="meta">圖片壓縮（預設不壓縮）</label>
      <div class="row">
        <input id="compress-factor" class="input" type="number" min="1.05" step="0.05" placeholder="縮小倍數，例如 2" />
        <input id="compress-target-sui" class="input" type="number" min="0.000001" step="0.000001" placeholder="目標 SUI，例如 0.03" />
      </div>
      <div id="compress-link-hint" class="meta">調整任一欄位，另一欄會自動連動</div>
      <div class="row" style="margin-top:8px;">
        <button id="btn-compress" class="btn btn-secondary">壓縮並套用</button>
        <button id="btn-cancel-compress" class="btn btn-danger hidden">取消壓縮</button>
      </div>
      <div id="compress-preview" class="preview">尚未壓縮</div>
      <div id="compress-preview-meta" class="meta"></div>
      <div class="row" style="margin-top:8px;">
        <button id="btn-upload" class="btn btn-ok">開始上傳（分塊）</button>
        <button id="btn-refresh" class="btn">重新載入圖片</button>
      </div>
      <div id="gas-estimate" class="meta">GAS: 尚未計算</div>
      <div id="compression-info" class="meta">壓縮資訊: 尚未選擇圖片</div>
      <div id="upload-progress" class="meta">上傳進度: 尚未開始</div>
    </div>
    <div id="log" class="console">系統啟動中...</div>
  </section>

  <section class="card">
    <h3 id="title-lookup" style="margin:0 0 8px;">透過 ID 查詢圖片</h3>
    <div class="row">
      <input id="lookup-id" class="input" type="text" placeholder="0x... image id" />
      <input id="lookup-password" class="input" type="password" placeholder="若有密碼請輸入" />
    </div>
    <div class="row" style="margin-top:8px;">
      <button id="btn-lookup" class="btn">依 ID 顯示</button>
      <div></div>
    </div>
    <div id="id-viewer" class="gallery"></div>
  </section>

  <section class="card">
    <h3 id="title-gallery" style="margin:0 0 8px;">我的圖片</h3>
    <div id="gallery" class="gallery"></div>
  </section>

  <div id="compress-lightbox" class="lightbox hidden">
    <div class="lightbox-scroll">
      <img id="compress-lightbox-img" alt="compressed preview full size" />
    </div>
    <div id="compress-lightbox-hint" class="lightbox-hint">按任一處返回頁面</div>
  </div>

  <script type="module">
    import { SuiClient, getFullnodeUrl } from "https://esm.sh/@mysten/sui.js@0.51.0/client";
    import { TransactionBlock } from "https://esm.sh/@mysten/sui.js@0.51.0/transactions";
    import { getWallets } from "https://esm.sh/@mysten/wallet-standard@0.20.1";

    const CONFIG = {
      DEFAULT_PACKAGE_ID: "0x2f558fcd835a9c328309a66db292f0fe9e6f13bfe2d583398c4bcf7623b3ff0c",
      LEGACY_PACKAGE_IDS: [
        "0xa9cfd77dc49c6cc06811914d24ae0b578d0cfaa1230129ae34752cedd50443c3",
        "0x21461b3f098a1e15b200080d0e39e82845b34c17d1c8d417454627e3fa0bd5df",
      ],
      MODULE_NAME: "on_chain_image",
      GAS_BUDGET_START_MIST: 300000000,
      GAS_BUDGET_DIRECT_MIST: 320000000,
      GAS_BUDGET_APPEND_MIST: 700000000,
      GAS_BUDGET_FINALIZE_MIST: 350000000,
      GAS_BUDGET_CANCEL_MIST: 300000000,
      GAS_BUDGET_DELETE_MIST: 300000000,
      MIN_BALANCE_MIST: 500000000,
      MAX_IMAGE_BYTES: 8000000,
      CHUNK_SIZE_BYTES: 15800,
      CHUNKS_PER_TX: 1,
      EST_DIRECT_BASE_MIST: 18000000,
      EST_DIRECT_PER_BYTE_MIST: 5200,
      EST_START_BASE_MIST: 12000000,
      EST_APPEND_BASE_MIST: 5000000,
      EST_APPEND_PER_BYTE_MIST: 3200,
      EST_FINALIZE_BASE_MIST: 15000000,
      EST_META_BYTE_MIST: 1200,
      EST_ENCRYPTED_META_BYTES: 96,
      EST_ENCRYPTED_DIRECT_EXTRA_MIST: 3000000,
      EST_ENCRYPTED_SESSION_EXTRA_MIST: 4000000,
      KDF_ROUNDS: 200000,
      MIN_PASSWORD_LEN: 8,
      TARGET_CHAIN: "sui:mainnet",
      TARGET_NETWORK: "mainnet",
    };

    const state = {
      wallet: null,
      account: null,
      okxSui: null,
      address: null,
      lang: localStorage.getItem("sui_image_lang") || "zh-Hant",
      chain: CONFIG.TARGET_CHAIN,
      walletType: null,
      client: new SuiClient({ url: getFullnodeUrl(CONFIG.TARGET_NETWORK) }),
      packageId: (() => {
        const stored = localStorage.getItem("sui_image_pkg");
        if (!stored) return CONFIG.DEFAULT_PACKAGE_ID;
        if (CONFIG.LEGACY_PACKAGE_IDS.includes(stored)) return CONFIG.DEFAULT_PACKAGE_ID;
        return stored;
      })(),
      preparedUpload: null,
      manualCompression: null,
      compressionPreviewUrl: null,
      compressionControl: "factor",
      currentUploadGasMist: 0n,
      logRows: [],
    };

    const MIST_PER_SUI = 1000000000n;
    const te = new TextEncoder();
    const $ = (id) => document.getElementById(id);
    const walletRegistry = getWallets();

    const I18N = {
      "zh-Hant": {
        page_title: "Sui 圖片分塊上傳",
        title_main: "Sui 分塊上傳 + 密碼保護",
        btn_disconnect: "斷開錢包",
        btn_slush: "連接 Slush / Sui Wallet",
        btn_okx: "連接 OKX Wallet",
        label_package: "Package ID",
        btn_apply_package: "套用 Package",
        label_file: "圖片檔案",
        label_compress: "圖片壓縮（預設不壓縮）",
        label_compress_link: "調整任一欄位，另一欄會自動連動",
        compress_mode_factor: "依縮小倍數",
        compress_mode_target: "依目標 SUI",
        ph_compress_factor: "縮小倍數，例如 2",
        ph_compress_target: "目標 SUI，例如 0.03",
        btn_compress: "壓縮並套用",
        btn_compressing: "壓縮中...",
        btn_cancel_compress: "取消壓縮",
        label_description: "圖片描述",
        label_password_toggle: "啟用密碼保護",
        btn_upload: "開始上傳（分塊）",
        btn_uploading: "上傳中...",
        btn_refresh: "重新載入圖片",
        title_lookup: "透過 ID 查詢圖片",
        btn_lookup: "依 ID 顯示",
        title_gallery: "我的圖片",
        ph_description: "例如：旅遊照片",
        ph_password: "至少 8 字元",
        ph_lookup_id: "0x... image id",
        ph_lookup_password: "若有密碼請輸入",
        gas_idle: "GAS: 尚未計算",
        upload_mode_direct: "單筆直傳",
        upload_mode_chunked: "分塊上傳",
        gas_estimate_info: "GAS 預估: 約 {sui} SUI ({mist} MIST) | {mode} | 分塊 {chunks}",
        comp_idle: "壓縮資訊: 尚未選擇圖片",
        compress_preview_idle: "尚未壓縮",
        compress_preview_original: "目前使用原圖（未壓縮）",
        compress_preview_applied: "已套用壓縮預覽",
        compress_result_none: "",
        compress_result_info: "壓縮結果: {width} x {height} | {size}",
        lightbox_back_hint: "按任一處返回頁面",
        progress_idle: "上傳進度: 尚未開始",
        comp_need_wallet: "壓縮資訊: 請先連接錢包",
        comp_calculating: "壓縮資訊: 計算中...",
        comp_failed: "壓縮資訊: 失敗 ({error})",
        gas_unavailable: "GAS: 無法估算 ({error})",
        comp_info: "壓縮資訊: {orig} -> {upload} ({ratio}% 減少), {mode}, 分塊 {chunks} 段, {enc}",
        comp_using_original: "原圖未壓縮",
        comp_using_compressed: "手動壓縮",
        gas_budget_info: "GAS 預算: start={start} / append={append}(每筆{chunkPerTx}塊) / finalize={finalize} SUI；共 {txCount} 筆",
        log_compression_applied: "已套用壓縮: {mode}, {from} -> {to} bytes",
        log_compression_canceled: "已取消壓縮，改用原圖",
        log_compression_keep_original: "{name} 已符合目標，維持原圖",
        log_loaded_owned_images: "已載入 {count} 張我的圖片",
        log_booting: "系統啟動中...",
        ready_hint: "就緒：請先連接錢包。若你重發佈合約，請更新 Package ID。",
        address_line: "地址: {address}",
        chain_forced: "鏈別: {chain}",
        card_loading: "載入中...",
        card_no_description: "(無描述)",
        meta_uploader: "上傳者: {uploader}",
        meta_size_chunks: "大小: {size} | 分塊: {chunks}",
        meta_public_hint: "公開圖片",
        meta_encrypted_hint: "加密圖片（需要密碼）",
        btn_copy_id: "複製 ID",
        btn_delete: "刪除",
        btn_download: "下載",
        enc_locked_message: "此圖片已加密，輸入密碼解鎖",
        enc_input_placeholder: "輸入密碼",
        btn_unlock: "解鎖顯示",
        err_enter_password: "請先輸入密碼",
        gallery_empty: "目前沒有圖片",
        err_enter_object_id: "請輸入 Object ID",
        err_object_id_not_found: "找不到這個 Object ID",
        warn_disconnect_with_err: "斷開連線時出現警告: {error}",
        log_disconnected: "已斷開錢包連線",
        warn_not_connected_switch: "尚未連接錢包，無法切換網路",
        log_okx_switch_requested: "OKX switchNetwork: 已請求切換到 SUI Mainnet",
        err_okx_switch_failed: "OKX switchNetwork 失敗: {error}",
        log_events_emit_sent: "standard:events.emit 已送出 chains=['sui:mainnet']",
        err_events_emit_failed: "standard:events.emit 失敗: {error}",
        err_okx_provider_missing: "找不到 OKX Sui 提供者，請確認已安裝並啟用 OKX Wallet",
        log_okx_sdk_switch_requested: "OKX 專用 SDK: 已請求切換到 SUI Mainnet",
        warn_okx_sdk_switch: "OKX 專用 SDK 切網警告: {error}",
        err_okx_no_account: "OKX 沒有回傳可用 Sui 帳號",
        err_image_decode_failed: "圖片解碼失敗",
        err_image_encode_failed: "圖片編碼失敗",
        err_canvas_context: "無法建立 Canvas Context",
        err_only_image_supported: "僅支援圖片檔",
        err_compress_too_large: "壓縮後仍過大 ({size} bytes)，超過 {max} bytes",
        err_wrong_password_or_damaged: "密碼錯誤或圖片資料已損壞",
        err_choose_image: "請先選擇圖片",
        err_compress_factor_invalid: "請輸入有效的縮小倍數（至少 1.05）",
        err_compress_target_invalid: "請輸入有效的目標 SUI",
        err_password_min: "密碼至少 {min} 字元",
        err_processed_too_large: "處理後資料過大 ({size} bytes)，超過 {max} bytes",
        err_okx_provider_unavailable: "OKX Sui provider 不可用",
        err_okx_sdk_no_sign_execute: "OKX 專用 SDK 不支援 signAndExecuteTransactionBlock",
      },
      "zh-Hans": {
        page_title: "Sui 图片分块上传",
        title_main: "Sui 分块上传 + 密码保护",
        btn_disconnect: "断开钱包",
        btn_slush: "连接 Slush / Sui Wallet",
        btn_okx: "连接 OKX Wallet",
        label_package: "Package ID",
        btn_apply_package: "应用 Package",
        label_file: "图片文件",
        label_compress: "图片压缩（默认不压缩）",
        label_compress_link: "调整任一栏位，另一栏会自动联动",
        compress_mode_factor: "按缩小倍数",
        compress_mode_target: "按目标 SUI",
        ph_compress_factor: "缩小倍数，例如 2",
        ph_compress_target: "目标 SUI，例如 0.03",
        btn_compress: "压缩并应用",
        btn_compressing: "压缩中...",
        btn_cancel_compress: "取消压缩",
        label_description: "图片描述",
        label_password_toggle: "启用密码保护",
        btn_upload: "开始上传（分块）",
        btn_uploading: "上传中...",
        btn_refresh: "重新加载图片",
        title_lookup: "通过 ID 查询图片",
        btn_lookup: "按 ID 显示",
        title_gallery: "我的图片",
        ph_description: "例如：旅行照片",
        ph_password: "至少 8 个字符",
        ph_lookup_id: "0x... image id",
        ph_lookup_password: "如有密码请输入",
        gas_idle: "GAS: 尚未计算",
        upload_mode_direct: "单笔直传",
        upload_mode_chunked: "分块上传",
        gas_estimate_info: "GAS 预估: 约 {sui} SUI ({mist} MIST) | {mode} | 分块 {chunks}",
        comp_idle: "压缩信息: 尚未选择图片",
        compress_preview_idle: "尚未压缩",
        compress_preview_original: "当前使用原图（未压缩）",
        compress_preview_applied: "已应用压缩预览",
        compress_result_none: "",
        compress_result_info: "压缩结果: {width} x {height} | {size}",
        lightbox_back_hint: "按任一处返回页面",
        progress_idle: "上传进度: 尚未开始",
        comp_need_wallet: "压缩信息: 请先连接钱包",
        comp_calculating: "压缩信息: 计算中...",
        comp_failed: "压缩信息: 失败 ({error})",
        gas_unavailable: "GAS: 无法估算 ({error})",
        comp_info: "压缩信息: {orig} -> {upload} ({ratio}% 减少), {mode}, 分块 {chunks} 段, {enc}",
        comp_using_original: "原图未压缩",
        comp_using_compressed: "手动压缩",
        gas_budget_info: "GAS 预算: start={start} / append={append}(每笔{chunkPerTx}块) / finalize={finalize} SUI；共 {txCount} 笔",
        log_compression_applied: "已应用压缩: {mode}, {from} -> {to} bytes",
        log_compression_canceled: "已取消压缩，改用原图",
        log_compression_keep_original: "{name} 已符合目标，保持原图",
        log_loaded_owned_images: "已加载 {count} 张我的图片",
        log_booting: "系统启动中...",
        ready_hint: "就绪：请先连接钱包。若重新发布合约，请更新 Package ID。",
        address_line: "地址: {address}",
        chain_forced: "链别: {chain}",
        card_loading: "加载中...",
        card_no_description: "(无描述)",
        meta_uploader: "上传者: {uploader}",
        meta_size_chunks: "大小: {size} | 分块: {chunks}",
        meta_public_hint: "公开图片",
        meta_encrypted_hint: "加密图片（需要密码）",
        btn_copy_id: "复制 ID",
        btn_delete: "删除",
        btn_download: "下载",
        enc_locked_message: "此图片已加密，输入密码解锁",
        enc_input_placeholder: "输入密码",
        btn_unlock: "解锁显示",
        err_enter_password: "请先输入密码",
        gallery_empty: "目前没有图片",
        err_enter_object_id: "请输入 Object ID",
        err_object_id_not_found: "找不到这个 Object ID",
        warn_disconnect_with_err: "断开连接时出现警告: {error}",
        log_disconnected: "已断开钱包连接",
        warn_not_connected_switch: "尚未连接钱包，无法切换网络",
        log_okx_switch_requested: "OKX switchNetwork: 已请求切换到 SUI Mainnet",
        err_okx_switch_failed: "OKX switchNetwork 失败: {error}",
        log_events_emit_sent: "standard:events.emit 已发送 chains=['sui:mainnet']",
        err_events_emit_failed: "standard:events.emit 失败: {error}",
        err_okx_provider_missing: "找不到 OKX Sui 提供者，请确认已安装并启用 OKX Wallet",
        log_okx_sdk_switch_requested: "OKX 专用 SDK: 已请求切换到 SUI Mainnet",
        warn_okx_sdk_switch: "OKX 专用 SDK 切网警告: {error}",
        err_okx_no_account: "OKX 未返回可用 Sui 账户",
        err_image_decode_failed: "图片解码失败",
        err_image_encode_failed: "图片编码失败",
        err_canvas_context: "无法建立 Canvas Context",
        err_only_image_supported: "仅支持图片文件",
        err_compress_too_large: "压缩后仍过大 ({size} bytes)，超过 {max} bytes",
        err_wrong_password_or_damaged: "密码错误或图片数据已损坏",
        err_choose_image: "请先选择图片",
        err_compress_factor_invalid: "请输入有效的缩小倍数（至少 1.05）",
        err_compress_target_invalid: "请输入有效的目标 SUI",
        err_password_min: "密码至少 {min} 个字符",
        err_processed_too_large: "处理后数据过大 ({size} bytes)，超过 {max} bytes",
        err_okx_provider_unavailable: "OKX Sui provider 不可用",
        err_okx_sdk_no_sign_execute: "OKX 专用 SDK 不支持 signAndExecuteTransactionBlock",
      },
      en: {
        page_title: "Sui Chunked Image Upload",
        title_main: "Sui Chunk Upload + Password Protection",
        btn_disconnect: "Disconnect Wallet",
        btn_slush: "Connect Slush / Sui Wallet",
        btn_okx: "Connect OKX Wallet",
        label_package: "Package ID",
        btn_apply_package: "Apply Package",
        label_file: "Image File",
        label_compress: "Image Compression (default: off)",
        label_compress_link: "Editing one field auto-syncs the other",
        compress_mode_factor: "By scale factor",
        compress_mode_target: "By target SUI",
        ph_compress_factor: "Scale factor, e.g. 2",
        ph_compress_target: "Target SUI, e.g. 0.03",
        btn_compress: "Compress and apply",
        btn_compressing: "Compressing...",
        btn_cancel_compress: "Cancel compression",
        label_description: "Image Description",
        label_password_toggle: "Enable Password Protection",
        btn_upload: "Start Upload (Chunked)",
        btn_uploading: "Uploading...",
        btn_refresh: "Reload Images",
        title_lookup: "Lookup Image by ID",
        btn_lookup: "Show by ID",
        title_gallery: "My Images",
        ph_description: "e.g. travel photo",
        ph_password: "At least 8 characters",
        ph_lookup_id: "0x... image id",
        ph_lookup_password: "Enter password if needed",
        gas_idle: "GAS: Not calculated yet",
        upload_mode_direct: "single transaction",
        upload_mode_chunked: "chunked upload",
        gas_estimate_info: "GAS estimate: about {sui} SUI ({mist} MIST) | {mode} | chunks: {chunks}",
        comp_idle: "Compression: No image selected",
        compress_preview_idle: "No compression applied",
        compress_preview_original: "Using original image (no compression)",
        compress_preview_applied: "Compressed preview applied",
        compress_result_none: "",
        compress_result_info: "Compressed: {width} x {height} | {size}",
        lightbox_back_hint: "Tap anywhere to return",
        progress_idle: "Upload progress: Not started",
        comp_need_wallet: "Compression: connect wallet first",
        comp_calculating: "Compression: calculating...",
        comp_failed: "Compression: failed ({error})",
        gas_unavailable: "GAS: estimate unavailable ({error})",
        comp_info: "Compression: {orig} -> {upload} ({ratio}% reduced), {mode}, chunks: {chunks}, {enc}",
        comp_using_original: "Original (no compression)",
        comp_using_compressed: "Manual compression",
        gas_budget_info: "GAS budget: start={start} / append={append} ({chunkPerTx} chunk/tx) / finalize={finalize} SUI; total {txCount} tx",
        log_compression_applied: "Compression applied: {mode}, {from} -> {to} bytes",
        log_compression_canceled: "Compression canceled, using original image",
        log_compression_keep_original: "{name} already meets target, keeping original",
        log_loaded_owned_images: "Loaded {count} owned images",
        log_booting: "System booting...",
        ready_hint: "Ready: connect wallet first. If you republish the contract, update Package ID.",
        address_line: "Address: {address}",
        chain_forced: "Chain: {chain}",
        card_loading: "Loading...",
        card_no_description: "(No description)",
        meta_uploader: "Uploader: {uploader}",
        meta_size_chunks: "Size: {size} | Chunks: {chunks}",
        meta_public_hint: "Public image",
        meta_encrypted_hint: "Encrypted image (password required)",
        btn_copy_id: "Copy ID",
        btn_delete: "Delete",
        btn_download: "Download",
        enc_locked_message: "This image is encrypted. Enter password to unlock.",
        enc_input_placeholder: "Enter password",
        btn_unlock: "Unlock",
        err_enter_password: "Please enter password first",
        gallery_empty: "No images yet",
        err_enter_object_id: "Please enter Object ID",
        err_object_id_not_found: "Object ID not found",
        warn_disconnect_with_err: "Warning while disconnecting: {error}",
        log_disconnected: "Wallet disconnected",
        warn_not_connected_switch: "Wallet is not connected, cannot switch network",
        log_okx_switch_requested: "OKX switchNetwork: requested SUI mainnet",
        err_okx_switch_failed: "OKX switchNetwork failed: {error}",
        log_events_emit_sent: "standard:events.emit sent chains=['sui:mainnet']",
        err_events_emit_failed: "standard:events.emit failed: {error}",
        err_okx_provider_missing: "OKX Sui provider not found. Please install and enable OKX Wallet.",
        log_okx_sdk_switch_requested: "OKX dedicated SDK: requested SUI mainnet",
        warn_okx_sdk_switch: "OKX dedicated SDK network switch warning: {error}",
        err_okx_no_account: "OKX did not return a usable Sui account",
        err_image_decode_failed: "Failed to decode image",
        err_image_encode_failed: "Failed to encode image",
        err_canvas_context: "Cannot create Canvas context",
        err_only_image_supported: "Only image files are supported",
        err_compress_too_large: "Compressed result is still too large ({size} bytes), over {max} bytes",
        err_wrong_password_or_damaged: "Wrong password or image data is corrupted",
        err_choose_image: "Please select an image first",
        err_compress_factor_invalid: "Please enter a valid scale factor (>= 1.05)",
        err_compress_target_invalid: "Please enter a valid target SUI",
        err_password_min: "Password must be at least {min} characters",
        err_processed_too_large: "Processed data is too large ({size} bytes), over {max} bytes",
        err_okx_provider_unavailable: "OKX Sui provider unavailable",
        err_okx_sdk_no_sign_execute: "OKX dedicated SDK does not support signAndExecuteTransactionBlock",
      },
      ja: {
        page_title: "Sui 画像チャンクアップロード",
        title_main: "Sui チャンクアップロード + パスワード保護",
        btn_disconnect: "ウォレット切断",
        btn_slush: "Slush / Sui Wallet に接続",
        btn_okx: "OKX Wallet に接続",
        label_package: "Package ID",
        btn_apply_package: "Package を適用",
        label_file: "画像ファイル",
        label_compress: "画像圧縮（初期値: 圧縮なし）",
        label_compress_link: "どちらかを変更すると、もう一方も自動同期されます",
        compress_mode_factor: "縮小倍率で指定",
        compress_mode_target: "目標 SUI で指定",
        ph_compress_factor: "縮小倍率（例: 2）",
        ph_compress_target: "目標 SUI（例: 0.03）",
        btn_compress: "圧縮して適用",
        btn_compressing: "圧縮中...",
        btn_cancel_compress: "圧縮を取り消す",
        label_description: "画像の説明",
        label_password_toggle: "パスワード保護を有効化",
        btn_upload: "アップロード開始（分割）",
        btn_uploading: "アップロード中...",
        btn_refresh: "画像を再読み込み",
        title_lookup: "ID で画像を検索",
        btn_lookup: "ID で表示",
        title_gallery: "自分の画像",
        ph_description: "例: 旅行写真",
        ph_password: "8文字以上",
        ph_lookup_id: "0x... image id",
        ph_lookup_password: "必要ならパスワード入力",
        gas_idle: "GAS: 未計算",
        upload_mode_direct: "単一トランザクション",
        upload_mode_chunked: "分割アップロード",
        gas_estimate_info: "GAS 見積: 約 {sui} SUI ({mist} MIST) | {mode} | チャンク {chunks}",
        comp_idle: "圧縮情報: 画像未選択",
        compress_preview_idle: "圧縮はまだ適用されていません",
        compress_preview_original: "現在は原図を使用（圧縮なし）",
        compress_preview_applied: "圧縮プレビューを適用済み",
        compress_result_none: "",
        compress_result_info: "圧縮結果: {width} x {height} | {size}",
        lightbox_back_hint: "任意の場所を押すと戻ります",
        progress_idle: "アップロード進捗: 未開始",
        comp_need_wallet: "圧縮情報: 先にウォレットを接続してください",
        comp_calculating: "圧縮情報: 計算中...",
        comp_failed: "圧縮情報: 失敗 ({error})",
        gas_unavailable: "GAS: 見積不可 ({error})",
        comp_info: "圧縮情報: {orig} -> {upload} ({ratio}% 削減), {mode}, チャンク {chunks}, {enc}",
        comp_using_original: "原図（圧縮なし）",
        comp_using_compressed: "手動圧縮",
        gas_budget_info: "GAS 予算: start={start} / append={append}(1Txあたり{chunkPerTx}チャンク) / finalize={finalize} SUI; 合計 {txCount} 件",
        log_compression_applied: "圧縮を適用しました: {mode}, {from} -> {to} bytes",
        log_compression_canceled: "圧縮を取り消し、原図を使用します",
        log_compression_keep_original: "{name} は目標を満たしているため原図を使用します",
        log_loaded_owned_images: "所有画像を {count} 件読み込みました",
        log_booting: "システム起動中...",
        ready_hint: "準備完了: 先にウォレットを接続してください。再デプロイ時は Package ID を更新してください。",
        address_line: "アドレス: {address}",
        chain_forced: "チェーン: {chain}",
        card_loading: "読み込み中...",
        card_no_description: "(説明なし)",
        meta_uploader: "アップローダー: {uploader}",
        meta_size_chunks: "サイズ: {size} | チャンク: {chunks}",
        meta_public_hint: "公開画像",
        meta_encrypted_hint: "暗号化画像（パスワード必須）",
        btn_copy_id: "ID をコピー",
        btn_delete: "削除",
        btn_download: "ダウンロード",
        enc_locked_message: "この画像は暗号化されています。パスワードを入力して解除してください",
        enc_input_placeholder: "パスワード入力",
        btn_unlock: "解除して表示",
        err_enter_password: "先にパスワードを入力してください",
        gallery_empty: "画像がありません",
        err_enter_object_id: "Object ID を入力してください",
        err_object_id_not_found: "Object ID が見つかりません",
        warn_disconnect_with_err: "切断時の警告: {error}",
        log_disconnected: "ウォレットを切断しました",
        warn_not_connected_switch: "ウォレット未接続のためネットワーク切替できません",
        log_okx_switch_requested: "OKX switchNetwork: SUI mainnet に切替要求",
        err_okx_switch_failed: "OKX switchNetwork 失敗: {error}",
        log_events_emit_sent: "standard:events.emit を送信 chains=['sui:mainnet']",
        err_events_emit_failed: "standard:events.emit 失敗: {error}",
        err_okx_provider_missing: "OKX Sui provider が見つかりません。OKX Wallet をインストールして有効化してください。",
        log_okx_sdk_switch_requested: "OKX 専用 SDK: SUI Mainnet 切替を要求",
        warn_okx_sdk_switch: "OKX 専用 SDK 切替警告: {error}",
        err_okx_no_account: "OKX から使用可能な Sui アカウントが返されませんでした",
        err_image_decode_failed: "画像のデコードに失敗しました",
        err_image_encode_failed: "画像のエンコードに失敗しました",
        err_canvas_context: "Canvas コンテキストを作成できません",
        err_only_image_supported: "画像ファイルのみ対応しています",
        err_compress_too_large: "圧縮後もサイズ超過です ({size} bytes), 上限 {max} bytes",
        err_wrong_password_or_damaged: "パスワードが正しくないか、画像データが破損しています",
        err_choose_image: "先に画像を選択してください",
        err_compress_factor_invalid: "有効な縮小倍率を入力してください（1.05 以上）",
        err_compress_target_invalid: "有効な目標 SUI を入力してください",
        err_password_min: "パスワードは最低 {min} 文字必要です",
        err_processed_too_large: "処理後データが大きすぎます ({size} bytes), 上限 {max} bytes",
        err_okx_provider_unavailable: "OKX Sui provider を利用できません",
        err_okx_sdk_no_sign_execute: "OKX 専用 SDK は signAndExecuteTransactionBlock をサポートしていません",
      },
      ko: {
        page_title: "Sui 이미지 청크 업로드",
        title_main: "Sui 청크 업로드 + 비밀번호 보호",
        btn_disconnect: "지갑 연결 해제",
        btn_slush: "Slush / Sui Wallet 연결",
        btn_okx: "OKX Wallet 연결",
        label_package: "Package ID",
        btn_apply_package: "Package 적용",
        label_file: "이미지 파일",
        label_compress: "이미지 압축(기본: 압축 안 함)",
        label_compress_link: "한쪽 값을 바꾸면 다른 쪽도 자동으로 동기화됩니다",
        compress_mode_factor: "축소 배율 기준",
        compress_mode_target: "목표 SUI 기준",
        ph_compress_factor: "축소 배율(예: 2)",
        ph_compress_target: "목표 SUI(예: 0.03)",
        btn_compress: "압축 후 적용",
        btn_compressing: "압축 중...",
        btn_cancel_compress: "압축 취소",
        label_description: "이미지 설명",
        label_password_toggle: "비밀번호 보호 사용",
        btn_upload: "업로드 시작(청크)",
        btn_uploading: "업로드 중...",
        btn_refresh: "이미지 새로고침",
        title_lookup: "ID로 이미지 조회",
        btn_lookup: "ID로 표시",
        title_gallery: "내 이미지",
        ph_description: "예: 여행 사진",
        ph_password: "최소 8자",
        ph_lookup_id: "0x... image id",
        ph_lookup_password: "필요 시 비밀번호 입력",
        gas_idle: "GAS: 아직 계산되지 않음",
        upload_mode_direct: "단일 트랜잭션",
        upload_mode_chunked: "청크 업로드",
        gas_estimate_info: "GAS 예상: 약 {sui} SUI ({mist} MIST) | {mode} | 청크 {chunks}",
        comp_idle: "압축 정보: 이미지 미선택",
        compress_preview_idle: "아직 압축이 적용되지 않았습니다",
        compress_preview_original: "현재 원본 이미지 사용(압축 없음)",
        compress_preview_applied: "압축 미리보기가 적용되었습니다",
        compress_result_none: "",
        compress_result_info: "압축 결과: {width} x {height} | {size}",
        lightbox_back_hint: "아무 곳이나 누르면 돌아갑니다",
        progress_idle: "업로드 진행: 미시작",
        comp_need_wallet: "압축 정보: 먼저 지갑을 연결하세요",
        comp_calculating: "압축 정보: 계산 중...",
        comp_failed: "압축 정보: 실패 ({error})",
        gas_unavailable: "GAS: 추정 불가 ({error})",
        comp_info: "압축 정보: {orig} -> {upload} ({ratio}% 감소), {mode}, 청크 {chunks}개, {enc}",
        comp_using_original: "원본(압축 없음)",
        comp_using_compressed: "수동 압축",
        gas_budget_info: "GAS 예산: start={start} / append={append}(tx당 {chunkPerTx}청크) / finalize={finalize} SUI; 총 {txCount}건",
        log_compression_applied: "압축 적용됨: {mode}, {from} -> {to} bytes",
        log_compression_canceled: "압축 취소, 원본 이미지 사용",
        log_compression_keep_original: "{name} 은(는) 이미 목표를 충족하여 원본을 유지합니다",
        log_loaded_owned_images: "내 이미지 {count}개를 불러왔습니다",
        log_booting: "시스템 시작 중...",
        ready_hint: "준비됨: 먼저 지갑을 연결하세요. 재배포 시 Package ID를 업데이트하세요.",
        address_line: "주소: {address}",
        chain_forced: "체인: {chain}",
        card_loading: "로딩 중...",
        card_no_description: "(설명 없음)",
        meta_uploader: "업로더: {uploader}",
        meta_size_chunks: "크기: {size} | 청크: {chunks}",
        meta_public_hint: "공개 이미지",
        meta_encrypted_hint: "암호화 이미지(비밀번호 필요)",
        btn_copy_id: "ID 복사",
        btn_delete: "삭제",
        btn_download: "다운로드",
        enc_locked_message: "이 이미지는 암호화되어 있습니다. 비밀번호를 입력해 해제하세요",
        enc_input_placeholder: "비밀번호 입력",
        btn_unlock: "해제 후 표시",
        err_enter_password: "먼저 비밀번호를 입력하세요",
        gallery_empty: "이미지가 없습니다",
        err_enter_object_id: "Object ID를 입력하세요",
        err_object_id_not_found: "Object ID를 찾을 수 없습니다",
        warn_disconnect_with_err: "연결 해제 중 경고: {error}",
        log_disconnected: "지갑 연결이 해제되었습니다",
        warn_not_connected_switch: "지갑이 연결되지 않아 네트워크를 전환할 수 없습니다",
        log_okx_switch_requested: "OKX switchNetwork: SUI mainnet 전환 요청 완료",
        err_okx_switch_failed: "OKX switchNetwork 실패: {error}",
        log_events_emit_sent: "standard:events.emit 전송됨 chains=['sui:mainnet']",
        err_events_emit_failed: "standard:events.emit 실패: {error}",
        err_okx_provider_missing: "OKX Sui provider를 찾을 수 없습니다. OKX Wallet 설치/활성화를 확인하세요.",
        log_okx_sdk_switch_requested: "OKX 전용 SDK: SUI Mainnet 전환 요청 완료",
        warn_okx_sdk_switch: "OKX 전용 SDK 네트워크 전환 경고: {error}",
        err_okx_no_account: "OKX가 사용 가능한 Sui 계정을 반환하지 않았습니다",
        err_image_decode_failed: "이미지 디코딩 실패",
        err_image_encode_failed: "이미지 인코딩 실패",
        err_canvas_context: "Canvas Context를 생성할 수 없습니다",
        err_only_image_supported: "이미지 파일만 지원합니다",
        err_compress_too_large: "압축 후에도 너무 큽니다 ({size} bytes), 제한 {max} bytes",
        err_wrong_password_or_damaged: "비밀번호가 틀렸거나 이미지 데이터가 손상되었습니다",
        err_choose_image: "먼저 이미지를 선택하세요",
        err_compress_factor_invalid: "유효한 축소 배율을 입력하세요(1.05 이상)",
        err_compress_target_invalid: "유효한 목표 SUI를 입력하세요",
        err_password_min: "비밀번호는 최소 {min}자여야 합니다",
        err_processed_too_large: "처리 후 데이터가 너무 큽니다 ({size} bytes), 제한 {max} bytes",
        err_okx_provider_unavailable: "OKX Sui provider를 사용할 수 없습니다",
        err_okx_sdk_no_sign_execute: "OKX 전용 SDK는 signAndExecuteTransactionBlock을 지원하지 않습니다",
      },
    };

    const PHRASE_MAP = {
      "zh-Hans": {
        "開始連接": "开始连接", "錢包已連線": "钱包已连接", "環境檢查通過": "环境检查通过", "連線失敗": "连接失败",
        "上傳完成，總 GAS": "上传完成，总 GAS", "上傳成功，總 GAS": "上传成功，总 GAS", "上傳失敗": "上传失败",
        "上傳進度": "上传进度", "壓縮資訊": "压缩信息", "建立上傳會話": "建立上传会话", "上傳批次": "上传批次",
        "完成上傳": "完成上传", "取消失敗上傳會話": "取消失败上传会话", "清理會話失敗": "清理会话失败",
        "請先連接錢包": "请先连接钱包", "請先輸入密碼": "请先输入密码", "請先輸入 Object ID": "请输入 Object ID",
        "查詢失敗": "查询失败", "載入失敗": "加载失败", "下載失敗": "下载失败", "刪除失敗": "删除失败",
        "刪除圖片": "删除图片", "刪除圖片中": "正在删除图片", "已下載圖片": "已下载图片", "已複製 ID": "已复制 ID",
        "失敗": "失败", "成功": "成功", "載入": "加载", "圖片": "图片", "密碼": "密码", "錢包": "钱包",
        "鏈別": "链别", "地址": "地址", "刪除": "删除", "下載": "下载", "查詢": "查询",
        "尚未開始": "尚未开始", "尚未選擇圖片": "尚未选择图片", "尚未計算": "尚未计算",
        "壓縮失敗": "压缩失败", "目前網路": "当前网络", "查不到 Package ID": "找不到 Package ID",
        "SUI 餘額不足，至少需要": "SUI 余额不足，至少需要", "錢包沒有回傳帳號": "钱包没有返回账号",
        "此錢包不支援 Sui 簽名 API": "此钱包不支持 Sui 签名 API", "單筆直傳上傳": "单笔直传上传",
        "準備上傳": "准备上传", "計算中": "计算中", "單筆直傳失敗，回退分塊流程": "单笔直传失败，回退分块流程",
        "已建立會話": "已建立会话", "請看下方清單": "请看下方清单", "刪除返還 SUI": "删除返还 SUI",
        "Package ID 不能為空": "Package ID 不能为空", "已更新 Package ID": "已更新 Package ID",
        "Package ID 套用成功": "Package ID 应用成功", "Package 驗證失敗": "Package 验证失败",
        "為加密圖片，請先輸入密碼": "为加密图片，请先输入密码", "這不是 Image 物件": "这不是 Image 对象",
        "已載入 ID": "已载入 ID", "GAS: 累計": "GAS: 累计"
      },
      en: {
        "開始連接": "Connecting", "錢包已連線": "Wallet connected", "環境檢查通過": "environment checks passed", "連線失敗": "Connection failed",
        "上傳完成，總 GAS": "Upload completed, total GAS", "上傳成功，總 GAS": "Upload succeeded, total GAS", "上傳失敗": "Upload failed",
        "上傳進度": "Upload progress", "壓縮資訊": "Compression", "建立上傳會話": "Create upload session", "上傳批次": "Upload batch",
        "完成上傳": "Finalize upload", "取消失敗上傳會話": "Cancel failed upload session", "清理會話失敗": "Session cleanup failed",
        "請先連接錢包": "Please connect wallet first", "請先輸入密碼": "Please enter password first", "請先輸入 Object ID": "Please enter Object ID",
        "查詢失敗": "Lookup failed", "載入失敗": "Load failed", "下載失敗": "Download failed", "刪除失敗": "Delete failed",
        "刪除圖片": "Delete image", "刪除圖片中": "Deleting image", "已下載圖片": "Image downloaded", "已複製 ID": "Copied ID",
        "圖片": "image", "密碼": "password", "錢包": "wallet", "鏈別": "Chain", "地址": "Address",
        "尚未開始": "Not started", "尚未選擇圖片": "No image selected", "尚未計算": "Not calculated yet",
        "壓縮失敗": "Compression failed", "目前網路": "Current network", "查不到 Package ID": "Package ID not found",
        "SUI 餘額不足，至少需要": "Insufficient SUI balance, at least required:", "錢包沒有回傳帳號": "Wallet did not return an account",
        "此錢包不支援 Sui 簽名 API": "This wallet does not support Sui signing API", "單筆直傳上傳": "Single direct upload",
        "準備上傳": "Preparing upload", "計算中": "calculating", "單筆直傳失敗，回退分塊流程": "Direct upload failed, fallback to chunked flow",
        "已建立會話": "Session created", "請看下方清單": "check the list below", "刪除返還 SUI": "Delete rebate SUI",
        "Package ID 不能為空": "Package ID cannot be empty", "已更新 Package ID": "Package ID updated",
        "Package ID 套用成功": "Package ID applied successfully", "Package 驗證失敗": "Package validation failed",
        "為加密圖片，請先輸入密碼": "is encrypted, please enter password first", "這不是 Image 物件": "This is not an Image object",
        "已載入 ID": "Loaded ID", "GAS: 累計": "GAS: cumulative"
      },
      ja: {
        "開始連接": "接続中", "錢包已連線": "ウォレット接続完了", "環境檢查通過": "環境チェック成功", "連線失敗": "接続失敗",
        "上傳完成，總 GAS": "アップロード完了、総 GAS", "上傳成功，總 GAS": "アップロード成功、総 GAS", "上傳失敗": "アップロード失敗",
        "上傳進度": "アップロード進捗", "壓縮資訊": "圧縮情報", "建立上傳會話": "アップロードセッション作成", "上傳批次": "バッチアップロード",
        "完成上傳": "アップロード完了処理", "取消失敗上傳會話": "失敗セッション取消", "清理會話失敗": "セッションクリーンアップ失敗",
        "請先連接錢包": "先にウォレットを接続してください", "請先輸入密碼": "先にパスワードを入力してください", "請先輸入 Object ID": "Object ID を入力してください",
        "查詢失敗": "検索失敗", "載入失敗": "読み込み失敗", "下載失敗": "ダウンロード失敗", "刪除失敗": "削除失敗",
        "刪除圖片": "画像削除", "刪除圖片中": "画像削除中", "已下載圖片": "画像をダウンロードしました", "已複製 ID": "ID をコピーしました",
        "圖片": "画像", "密碼": "パスワード", "錢包": "ウォレット", "鏈別": "チェーン", "地址": "アドレス",
        "壓縮失敗": "圧縮失敗", "目前網路": "現在のネットワーク", "查不到 Package ID": "Package ID が見つかりません",
        "SUI 餘額不足，至少需要": "SUI 残高不足、最低必要:", "錢包沒有回傳帳號": "ウォレットからアカウントが返されませんでした",
        "此錢包不支援 Sui 簽名 API": "このウォレットは Sui 署名 API をサポートしていません", "單筆直傳上傳": "単発直接アップロード",
        "準備上傳": "アップロード準備", "計算中": "計算中", "單筆直傳失敗，回退分塊流程": "単発アップロード失敗、分割フローへフォールバック",
        "已建立會話": "セッション作成済み", "請看下方清單": "下の一覧を確認してください", "刪除返還 SUI": "削除返還 SUI",
        "Package ID 不能為空": "Package ID は空にできません", "已更新 Package ID": "Package ID を更新しました",
        "Package ID 套用成功": "Package ID の適用に成功しました", "Package 驗證失敗": "Package 検証失敗",
        "為加密圖片，請先輸入密碼": "暗号化画像のため、先にパスワードを入力してください", "這不是 Image 物件": "これは Image オブジェクトではありません",
        "已載入 ID": "ID を読み込みました", "GAS: 累計": "GAS: 累計"
      },
      ko: {
        "開始連接": "연결 중", "錢包已連線": "지갑 연결 완료", "環境檢查通過": "환경 점검 통과", "連線失敗": "연결 실패",
        "上傳完成，總 GAS": "업로드 완료, 총 GAS", "上傳成功，總 GAS": "업로드 성공, 총 GAS", "上傳失敗": "업로드 실패",
        "上傳進度": "업로드 진행", "壓縮資訊": "압축 정보", "建立上傳會話": "업로드 세션 생성", "上傳批次": "업로드 배치",
        "完成上傳": "업로드 완료 처리", "取消失敗上傳會話": "실패 세션 취소", "清理會話失敗": "세션 정리 실패",
        "請先連接錢包": "먼저 지갑을 연결하세요", "請先輸入密碼": "먼저 비밀번호를 입력하세요", "請先輸入 Object ID": "Object ID를 입력하세요",
        "查詢失敗": "조회 실패", "載入失敗": "불러오기 실패", "下載失敗": "다운로드 실패", "刪除失敗": "삭제 실패",
        "刪除圖片": "이미지 삭제", "刪除圖片中": "이미지 삭제 중", "已下載圖片": "이미지 다운로드 완료", "已複製 ID": "ID 복사 완료",
        "圖片": "이미지", "密碼": "비밀번호", "錢包": "지갑", "鏈別": "체인", "地址": "주소",
        "壓縮失敗": "압축 실패", "目前網路": "현재 네트워크", "查不到 Package ID": "Package ID를 찾을 수 없습니다",
        "SUI 餘額不足，至少需要": "SUI 잔액 부족, 최소 필요:", "錢包沒有回傳帳號": "지갑이 계정을 반환하지 않았습니다",
        "此錢包不支援 Sui 簽名 API": "이 지갑은 Sui 서명 API를 지원하지 않습니다", "單筆直傳上傳": "단일 직접 업로드",
        "準備上傳": "업로드 준비", "計算中": "계산 중", "單筆直傳失敗，回退分塊流程": "직접 업로드 실패, 청크 업로드로 전환",
        "已建立會話": "세션 생성됨", "請看下方清單": "아래 목록을 확인하세요", "刪除返還 SUI": "삭제 반환 SUI",
        "Package ID 不能為空": "Package ID는 비워둘 수 없습니다", "已更新 Package ID": "Package ID가 업데이트되었습니다",
        "Package ID 套用成功": "Package ID 적용 성공", "Package 驗證失敗": "Package 검증 실패",
        "為加密圖片，請先輸入密碼": "암호화 이미지입니다. 먼저 비밀번호를 입력하세요", "這不是 Image 物件": "Image 객체가 아닙니다",
        "已載入 ID": "ID를 불러왔습니다", "GAS: 累計": "GAS: 누적"
      },
    };

    function template(str, vars = {}) { return String(str).replace(/\{(\w+)\}/g, (_, k) => vars[k] ?? `{${k}}`); }
    function t(key, vars = {}) {
      const lang = I18N[state.lang] ? state.lang : "zh-Hant";
      const raw = I18N[lang]?.[key] ?? I18N["zh-Hant"]?.[key] ?? key;
      return template(raw, vars);
    }
    function tl(text) {
      if (state.lang === "zh-Hant") return String(text);
      let out = String(text);
      const map = PHRASE_MAP[state.lang] || {};
      for (const [from, to] of Object.entries(map).sort((a, b) => b[0].length - a[0].length)) out = out.replaceAll(from, to);
      return out;
    }
    function applyLanguage() {
      if (!I18N[state.lang]) state.lang = "zh-Hant";
      localStorage.setItem("sui_image_lang", state.lang);
      document.documentElement.lang = state.lang;
      document.title = t("page_title");
      $("title-main").textContent = t("title_main");
      $("btn-disconnect").textContent = t("btn_disconnect");
      $("btn-slush").textContent = t("btn_slush");
      $("btn-okx").textContent = t("btn_okx");
      $("label-package").textContent = t("label_package");
      $("btn-apply-package").textContent = t("btn_apply_package");
      $("label-file").textContent = t("label_file");
      $("label-compress").textContent = t("label_compress");
      $("compress-link-hint").textContent = t("label_compress_link");
      $("compress-lightbox-hint").textContent = t("lightbox_back_hint");
      $("compress-factor").placeholder = t("ph_compress_factor");
      $("compress-target-sui").placeholder = t("ph_compress_target");
      $("btn-compress").textContent = $("btn-compress").disabled ? t("btn_compressing") : t("btn_compress");
      $("btn-cancel-compress").textContent = t("btn_cancel_compress");
      $("label-description").textContent = t("label_description");
      $("label-password-toggle").textContent = t("label_password_toggle");
      $("btn-upload").textContent = $("btn-upload").disabled ? t("btn_uploading") : t("btn_upload");
      $("btn-refresh").textContent = t("btn_refresh");
      $("title-lookup").textContent = t("title_lookup");
      $("btn-lookup").textContent = t("btn_lookup");
      $("title-gallery").textContent = t("title_gallery");
      $("address").textContent = state.address ? t("address_line", { address: state.address }) : "";
      $("chain").textContent = state.chain ? t("chain_forced", { chain: state.chain, network: CONFIG.TARGET_NETWORK }) : "";
      $("description-input").placeholder = t("ph_description");
      $("password-input").placeholder = t("ph_password");
      $("lookup-id").placeholder = t("ph_lookup_id");
      $("lookup-password").placeholder = t("ph_lookup_password");
      const noSelectedFile = !$("file-input").files?.[0];
      const isUploadingNow = $("btn-upload").disabled;
      if (noSelectedFile && !isUploadingNow) {
        setGas(t("gas_idle"));
        setComp(t("comp_idle"));
        setProg(t("progress_idle"));
      }
      if (!state.manualCompression) {
        $("compress-preview").textContent = $("file-input").files?.[0] ? t("compress_preview_original") : t("compress_preview_idle");
        if (!$("file-input").files?.[0]) setCompressionResultMeta(t("compress_result_none"));
      } else {
        setCompressionResultMeta(t("compress_result_info", {
          width: state.manualCompression.width || "-",
          height: state.manualCompression.height || "-",
          size: fmtBytes(state.manualCompression.bytes?.length || 0),
        }));
      }
      renderLog();
    }

    function renderLog() {
      const e = $("log");
      const lines = state.logRows.map((row) => {
        const msg = row.key ? t(row.key, row.vars || {}) : tl(row.raw || "");
        return `[${row.time}] ${msg}`;
      });
      e.textContent = lines.join("\n");
      e.scrollTop = e.scrollHeight;
    }
    function nowAmPmTime() {
      return new Date().toLocaleTimeString("en-US", {
        hour12: true,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
      });
    }
    function log(msg) {
      state.logRows.push({ time: nowAmPmTime(), raw: String(msg) });
      renderLog();
    }
    function logKey(key, vars = {}) {
      state.logRows.push({ time: nowAmPmTime(), key, vars });
      renderLog();
    }
    function setGas(text) { $("gas-estimate").textContent = tl(text); }
    function setComp(text) { $("compression-info").textContent = tl(text); }
    function setProg(text) { $("upload-progress").textContent = tl(text); }
    function fmtBytes(bytes) {
      const b = Number(bytes || 0);
      if (b < 1024) return `${b} B`;
      if (b < 1024 * 1024) return `${(b / 1024).toFixed(1)} KB`;
      return `${(b / (1024 * 1024)).toFixed(2)} MB`;
    }
    function setCompressionResultMeta(text = "") {
      $("compress-preview-meta").textContent = tl(text || "");
    }
    function toBigInt(v) { try { return BigInt(v ?? 0); } catch { return 0n; } }
    function fmtSui(m) { const v = toBigInt(m); return `${(v / MIST_PER_SUI).toString()}.${(v % MIST_PER_SUI).toString().padStart(9, "0").slice(0, 6)}`; }
    function netGas(g) { const c = toBigInt(g?.computationCost); const s = toBigInt(g?.storageCost); const r = toBigInt(g?.storageRebate); const n = c + s - r; return n > 0n ? n : 0n; }
    function chainToNetwork(c) { if (!c || typeof c !== "string") return "mainnet"; if (c.includes("testnet")) return "testnet"; if (c.includes("devnet")) return "devnet"; return "mainnet"; }
    function target(fn) { return `${state.packageId}::${CONFIG.MODULE_NAME}::${fn}`; }
    function b(raw) { if (Array.isArray(raw)) return raw.map((x) => Number(x)); if (raw && Array.isArray(raw.bytes)) return raw.bytes.map((x) => Number(x)); return []; }
    function short(a) { if (!a || a.length < 14) return a || ""; return `${a.slice(0, 8)}...${a.slice(-6)}`; }
    function isConnected() { return !!state.address && ((state.walletType === "okx" && !!state.okxSui) || !!state.wallet); }
    function fileKey(file) { return `${file.name}:${file.size}:${file.lastModified}`; }
    function parseSuiToMist(input) {
      const raw = String(input || "").trim();
      if (!raw) return null;
      if (!/^\d+(\.\d+)?$/.test(raw)) return null;
      const [intPart, fracPart = ""] = raw.split(".");
      const whole = BigInt(intPart || "0");
      const frac = BigInt((fracPart + "000000000").slice(0, 9));
      return whole * MIST_PER_SUI + frac;
    }
    function estimateTotalGasMist(dataBytes, chunkCount, description, mimeType, isEncrypted) {
      const bytes = BigInt(Math.max(0, Number(dataBytes) || 0));
      const chunks = Math.max(1, Number(chunkCount) || 1);
      const descBytes = BigInt(te.encode(String(description || "")).length);
      const mimeBytes = BigInt(te.encode(String(mimeType || "")).length);
      const encryptedMetaBytes = isEncrypted ? BigInt(CONFIG.EST_ENCRYPTED_META_BYTES) : 0n;
      const extraMetaBytes = descBytes + mimeBytes + encryptedMetaBytes;

      let total = 0n;
      if (chunks === 1) {
        total = BigInt(CONFIG.EST_DIRECT_BASE_MIST) + bytes * BigInt(CONFIG.EST_DIRECT_PER_BYTE_MIST);
        if (isEncrypted) total += BigInt(CONFIG.EST_ENCRYPTED_DIRECT_EXTRA_MIST);
      } else {
        total = BigInt(CONFIG.EST_START_BASE_MIST) + BigInt(CONFIG.EST_FINALIZE_BASE_MIST);
        if (isEncrypted) total += BigInt(CONFIG.EST_ENCRYPTED_SESSION_EXTRA_MIST);
        let remain = Number(bytes);
        for (let i = 0; i < chunks; i += 1) {
          const each = Math.min(CONFIG.CHUNK_SIZE_BYTES, remain);
          remain -= each;
          total += BigInt(CONFIG.EST_APPEND_BASE_MIST) + BigInt(each) * BigInt(CONFIG.EST_APPEND_PER_BYTE_MIST);
        }
      }
      total += extraMetaBytes * BigInt(CONFIG.EST_META_BYTE_MIST);
      return total > 0n ? total : 0n;
    }
    function estimateMistByPayloadBytes(payloadBytes, mimeType) {
      const file = $("file-input").files?.[0];
      const description = $("description-input").value.trim() || file?.name || "image";
      const usePassword = $("password-toggle").checked;
      const totalBytes = Number(payloadBytes) + (usePassword ? 16 : 0);
      const chunks = Math.max(1, Math.ceil(totalBytes / CONFIG.CHUNK_SIZE_BYTES));
      return estimateTotalGasMist(totalBytes, chunks, description, mimeType || file?.type || "image/webp", usePassword);
    }
    function syncTargetFromFactor() {
      const file = $("file-input").files?.[0];
      if (!file) return;
      const factor = Number($("compress-factor").value);
      if (!(factor >= 1.05)) return;
      const predictedBytes = Math.max(1, Math.floor(file.size / Math.pow(factor, 2)));
      const mist = estimateMistByPayloadBytes(predictedBytes, "image/webp");
      $("compress-target-sui").value = fmtSui(mist);
    }
    function syncFactorFromTarget() {
      const file = $("file-input").files?.[0];
      if (!file) return;
      const targetMist = parseSuiToMist($("compress-target-sui").value);
      if (!targetMist || targetMist <= 0n) return;
      const rawMist = estimateMistByPayloadBytes(file.size, file.type || "image/webp");
      if (targetMist >= rawMist) {
        $("compress-factor").value = "1.05";
        return;
      }
      const ratio = Number(rawMist) / Number(targetMist);
      const factor = Math.max(1.05, Math.min(12, Math.sqrt(Math.max(1, ratio))));
      $("compress-factor").value = factor.toFixed(2);
    }
    function syncCompressionLinkedFields() {
      if (state.compressionControl === "target") syncFactorFromTarget();
      else syncTargetFromFactor();
    }
    function setCompressedPreview(bytes, mimeType, hintText = "") {
      const el = $("compress-preview");
      if (state.compressionPreviewUrl) {
        URL.revokeObjectURL(state.compressionPreviewUrl);
        state.compressionPreviewUrl = null;
      }
      const blob = new Blob([bytes], { type: mimeType || "image/webp" });
      const url = URL.createObjectURL(blob);
      state.compressionPreviewUrl = url;
      el.innerHTML = "";
      const img = document.createElement("img");
      img.src = url;
      img.alt = "compressed preview";
      el.appendChild(img);
      if (hintText) el.title = hintText;
    }
    function openLightbox(url) {
      if (!url) return;
      $("compress-lightbox-img").src = url;
      $("compress-lightbox").classList.remove("hidden");
    }
    function closeLightbox() {
      $("compress-lightbox").classList.add("hidden");
      $("compress-lightbox-img").removeAttribute("src");
    }
    function toggleLightbox(url) {
      const box = $("compress-lightbox");
      if (box.classList.contains("hidden")) openLightbox(url);
      else closeLightbox();
    }
    function clearManualCompression() {
      state.manualCompression = null;
      closeLightbox();
      if (state.compressionPreviewUrl) {
        URL.revokeObjectURL(state.compressionPreviewUrl);
        state.compressionPreviewUrl = null;
      }
      $("btn-cancel-compress").classList.add("hidden");
      $("compress-preview").textContent = $("file-input").files?.[0] ? t("compress_preview_original") : t("compress_preview_idle");
      setCompressionResultMeta(t("compress_result_none"));
    }

    function resetUiAfterDisconnect() {
      state.wallet = null;
      state.account = null;
      state.okxSui = null;
      state.address = null;
      state.chain = CONFIG.TARGET_CHAIN;
      state.walletType = null;
      state.client = new SuiClient({ url: getFullnodeUrl(CONFIG.TARGET_NETWORK) });
      state.preparedUpload = null;
      state.currentUploadGasMist = 0n;

      $("connect-ui").classList.remove("hidden");
      $("app-ui").classList.add("hidden");
      $("btn-disconnect").classList.add("hidden");
      $("gallery").innerHTML = "";
      $("id-viewer").innerHTML = "";
      $("file-input").value = "";
      $("password-input").value = "";
      $("compress-factor").value = "";
      $("compress-target-sui").value = "";
      clearManualCompression();
      setGas(t("gas_idle"));
      setComp(t("comp_idle"));
      setProg(t("progress_idle"));
    }

    async function disconnectWallet() {
      try {
        if (state.walletType === "okx" && state.okxSui && typeof state.okxSui.disconnect === "function") {
          await state.okxSui.disconnect();
        } else if (state.wallet?.features?.["standard:disconnect"]) {
          await state.wallet.features["standard:disconnect"].disconnect();
        } else if (typeof state.wallet?.disconnect === "function") {
          await state.wallet.disconnect();
        }
      } catch (err) {
        logKey("warn_disconnect_with_err", { error: err.message });
      } finally {
        resetUiAfterDisconnect();
        logKey("log_disconnected");
      }
    }

    async function switchToSuiMainnet() {
      if (!isConnected()) {
        logKey("warn_not_connected_switch");
        return false;
      }
      let switched = false;
      const okxSui = state.okxSui || globalThis.okxwallet?.sui;
      if (okxSui && typeof okxSui.switchNetwork === "function") {
        try {
          await okxSui.switchNetwork(CONFIG.TARGET_CHAIN);
          switched = true;
          logKey("log_okx_switch_requested");
        } catch (err) {
          logKey("err_okx_switch_failed", { error: err.message });
        }
      }

      const eventsFeature = state.wallet?.features?.["standard:events"];
      if (eventsFeature && typeof eventsFeature.emit === "function") {
        try {
          eventsFeature.emit("change", { chains: [CONFIG.TARGET_CHAIN] });
          switched = true;
          logKey("log_events_emit_sent");
        } catch (err) {
          logKey("err_events_emit_failed", { error: err.message });
        }
      }

      state.chain = CONFIG.TARGET_CHAIN;
      state.client = new SuiClient({ url: getFullnodeUrl(CONFIG.TARGET_NETWORK) });
      $("chain").textContent = t("chain_forced", { chain: state.chain, network: CONFIG.TARGET_NETWORK });
      return switched;
    }

    async function connectOkxDedicated() {
      const okxSui = globalThis.okxwallet?.sui;
      if (!okxSui) throw new Error(t("err_okx_provider_missing"));

      state.wallet = null;
      state.account = null;
      state.okxSui = okxSui;
      state.walletType = "okx";

      if (typeof okxSui.switchNetwork === "function") {
        try {
          await okxSui.switchNetwork(CONFIG.TARGET_CHAIN);
          logKey("log_okx_sdk_switch_requested");
        } catch (err) {
          logKey("warn_okx_sdk_switch", { error: err.message });
        }
      }

      let accounts = [];
      if (typeof okxSui.connect === "function") {
        const res = await okxSui.connect();
        if (Array.isArray(res)) accounts = res;
        else if (Array.isArray(res?.accounts)) accounts = res.accounts;
      }
      if (!accounts.length && typeof okxSui.getAccounts === "function") accounts = await okxSui.getAccounts();
      if (!accounts.length && typeof okxSui.requestAccounts === "function") accounts = await okxSui.requestAccounts();

      const first = accounts?.[0];
      const address = typeof first === "string" ? first : first?.address || first?.account?.address;
      const chain = typeof first === "object" ? (first?.chains?.[0] || first?.chain) : null;
      if (!address) throw new Error(t("err_okx_no_account"));

      state.address = address;
      state.chain = chain || CONFIG.TARGET_CHAIN;
    }

    function fileToImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error(t("err_image_decode_failed"))); };
        img.src = url;
      });
    }

    function canvasToBlob(canvas, mimeType, quality) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) { reject(new Error(t("err_image_encode_failed"))); return; }
          resolve(blob);
        }, mimeType, quality);
      });
    }

    async function encodeCandidate(img, scale, mimeType, quality, label) {
      const w = Math.max(1, Math.round(img.naturalWidth * scale));
      const h = Math.max(1, Math.round(img.naturalHeight * scale));
      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error(t("err_canvas_context"));
      ctx.drawImage(img, 0, 0, w, h);
      const blob = await canvasToBlob(canvas, mimeType, quality);
      return { bytes: new Uint8Array(await blob.arrayBuffer()), mimeType, label, width: w, height: h };
    }

    async function getSourceUploadAsset(file) {
      const rawBytes = new Uint8Array(await file.arrayBuffer());
      const rawMime = file.type || "application/octet-stream";
      if (!rawMime.startsWith("image/")) throw new Error(t("err_only_image_supported"));

      const manual = state.manualCompression;
      if (manual && manual.sourceKey === fileKey(file)) {
        return {
          originalBytes: rawBytes.length,
          bytes: manual.bytes,
          mimeType: manual.mimeType,
          compressionMode: manual.mode,
        };
      }

      return {
        originalBytes: rawBytes.length,
        bytes: rawBytes,
        mimeType: rawMime,
        compressionMode: t("comp_using_original"),
      };
    }

    async function compressWithFactor(file, factor) {
      if (!(factor >= 1.05)) throw new Error(t("err_compress_factor_invalid"));
      const rawMime = file.type || "image/png";
      if (!rawMime.startsWith("image/")) throw new Error(t("err_only_image_supported"));
      const img = await fileToImage(file);
      const scale = 1 / factor;
      const candidate = await encodeCandidate(img, scale, "image/webp", 0.995, `x${factor.toFixed(2)}`);
      return {
        bytes: candidate.bytes,
        mimeType: candidate.mimeType,
        mode: `${t("comp_using_compressed")} x${factor.toFixed(2)}`,
        isOriginal: false,
        width: candidate.width,
        height: candidate.height,
      };
    }

    async function compressWithTargetSui(file, targetMist) {
      if (!targetMist || targetMist <= 0n) throw new Error(t("err_compress_target_invalid"));
      const rawBytes = new Uint8Array(await file.arrayBuffer());
      const rawMime = file.type || "image/png";
      if (!rawMime.startsWith("image/")) throw new Error(t("err_only_image_supported"));
      const img = await fileToImage(file);
      const description = $("description-input").value.trim() || file.name || "image";
      const usePassword = $("password-toggle").checked;

      const rawDataBytes = rawBytes.length + (usePassword ? 16 : 0);
      const rawChunkCount = Math.max(1, Math.ceil(rawDataBytes / CONFIG.CHUNK_SIZE_BYTES));
      const rawEst = estimateTotalGasMist(rawDataBytes, rawChunkCount, description, rawMime, usePassword);
      if (rawEst <= targetMist) {
        return {
          bytes: rawBytes,
          mimeType: rawMime,
          mode: t("comp_using_original"),
          isOriginal: true,
          width: img.naturalWidth,
          height: img.naturalHeight,
        };
      }

      const factors = [1.05, 1.1, 1.2, 1.35, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 8];
      const qualities = [1.0, 0.995, 0.99, 0.985, 0.98, 0.97, 0.95, 0.93, 0.9];
      let best = null;

      for (const factor of factors) {
        const scale = 1 / factor;
        for (const q of qualities) {
          const candidate = await encodeCandidate(img, scale, "image/webp", q, `x${factor.toFixed(2)}-q${q}`);
          if (!best || candidate.bytes.length < best.bytes.length) {
            best = { bytes: candidate.bytes, mimeType: candidate.mimeType, factor, quality: q, width: candidate.width, height: candidate.height };
          }

          const dataBytes = candidate.bytes.length + (usePassword ? 16 : 0);
          const chunkCount = Math.max(1, Math.ceil(dataBytes / CONFIG.CHUNK_SIZE_BYTES));
          const estimateMist = estimateTotalGasMist(dataBytes, chunkCount, description, candidate.mimeType, usePassword);
          if (estimateMist <= targetMist) {
            return {
              bytes: candidate.bytes,
              mimeType: candidate.mimeType,
              mode: `${t("comp_using_compressed")} x${factor.toFixed(2)} q${q}`,
              isOriginal: false,
              width: candidate.width,
              height: candidate.height,
            };
          }
        }
      }

      if (!best) throw new Error(t("err_image_encode_failed"));
      return {
        bytes: best.bytes,
        mimeType: best.mimeType,
        mode: `${t("comp_using_compressed")} x${best.factor.toFixed(2)} q${best.quality}`,
        isOriginal: false,
        width: best.width,
        height: best.height,
      };
    }

    async function deriveAesKey(password, saltBytes, rounds) {
      const mat = await crypto.subtle.importKey("raw", te.encode(password), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: rounds, hash: "SHA-256" },
        mat,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptBytes(plainBytes, password) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const nonce = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveAesKey(password, salt, CONFIG.KDF_ROUNDS);
      const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: nonce }, key, plainBytes);
      return { cipherBytes: new Uint8Array(encrypted), salt, nonce, rounds: CONFIG.KDF_ROUNDS };
    }

    async function decryptBytes(cipherBytes, password, saltBytes, nonceBytes, rounds) {
      const key = await deriveAesKey(password, saltBytes, rounds);
      try {
        const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv: nonceBytes }, key, cipherBytes);
        return new Uint8Array(plain);
      } catch {
        throw new Error(t("err_wrong_password_or_damaged"));
      }
    }

    function chunkBytes(bytes, size) {
      const chunks = [];
      for (let i = 0; i < bytes.length; i += size) chunks.push(Array.from(bytes.slice(i, i + size)));
      return chunks;
    }

    async function buildDraftEstimate() {
      const file = $("file-input").files?.[0];
      if (!file) throw new Error(t("err_choose_image"));
      const description = $("description-input").value.trim() || file.name || "image";
      const usePassword = $("password-toggle").checked;

      const asset = await getSourceUploadAsset(file);
      const payloadBytes = asset.bytes.length + (usePassword ? 16 : 0);
      if (payloadBytes > CONFIG.MAX_IMAGE_BYTES) {
        throw new Error(t("err_processed_too_large", { size: payloadBytes, max: CONFIG.MAX_IMAGE_BYTES }));
      }

      const chunkCount = Math.max(1, Math.ceil(payloadBytes / CONFIG.CHUNK_SIZE_BYTES));
      const estimatedMist = estimateTotalGasMist(payloadBytes, chunkCount, description, asset.mimeType, usePassword);
      return {
        description,
        mimeType: asset.mimeType,
        originalBytes: asset.originalBytes,
        uploadBytes: payloadBytes,
        chunkCount,
        isEncrypted: usePassword,
        compressionMode: asset.compressionMode,
        estimatedMist,
      };
    }

    async function prepareUploadFromUI() {
      const file = $("file-input").files?.[0];
      if (!file) throw new Error(t("err_choose_image"));

      const description = $("description-input").value.trim() || file.name || "image";
      const usePassword = $("password-toggle").checked;
      const password = $("password-input").value;

      const asset = await getSourceUploadAsset(file);
      let payloadBytes = asset.bytes;
      let isEncrypted = false;
      let kdfSalt = [];
      let kdfRounds = 0;
      let nonce = [];

      if (usePassword) {
        if (password.length < CONFIG.MIN_PASSWORD_LEN) throw new Error(t("err_password_min", { min: CONFIG.MIN_PASSWORD_LEN }));
        const encrypted = await encryptBytes(payloadBytes, password);
        payloadBytes = encrypted.cipherBytes;
        isEncrypted = true;
        kdfSalt = Array.from(encrypted.salt);
        kdfRounds = encrypted.rounds;
        nonce = Array.from(encrypted.nonce);
      }

      if (payloadBytes.length > CONFIG.MAX_IMAGE_BYTES) {
        throw new Error(t("err_processed_too_large", { size: payloadBytes.length, max: CONFIG.MAX_IMAGE_BYTES }));
      }

      const chunks = chunkBytes(payloadBytes, CONFIG.CHUNK_SIZE_BYTES);
      return {
        key: `${fileKey(file)}:${description}:${usePassword ? "enc" : "plain"}:${asset.compressionMode}`,
        description,
        mimeType: asset.mimeType,
        bytes: payloadBytes,
        chunks,
        isEncrypted,
        kdfSalt,
        kdfRounds,
        nonce,
        originalBytes: asset.originalBytes,
        uploadBytes: payloadBytes.length,
        compressionMode: asset.compressionMode,
      };
    }

    function updatePreparedInfo(prepared) {
      const chunkCount = prepared.chunkCount || prepared.chunks?.length || 1;
      const saved = prepared.originalBytes - prepared.uploadBytes;
      const ratio = prepared.originalBytes > 0 ? ((saved / prepared.originalBytes) * 100).toFixed(1) : "0.0";
      const enc = prepared.isEncrypted ? `Encrypted (AES-256-GCM / PBKDF2-${CONFIG.KDF_ROUNDS})` : t("meta_public_hint");
      const estimatedMist = prepared.estimatedMist ?? estimateTotalGasMist(
        prepared.uploadBytes,
        chunkCount,
        prepared.description,
        prepared.mimeType,
        prepared.isEncrypted
      );
      setComp(t("comp_info", {
        orig: fmtBytes(prepared.originalBytes),
        upload: fmtBytes(prepared.uploadBytes),
        ratio,
        mode: prepared.compressionMode,
        chunks: chunkCount,
        enc,
      }));
      const mode = chunkCount === 1 ? t("upload_mode_direct") : t("upload_mode_chunked");
      setGas(t("gas_estimate_info", { sui: fmtSui(estimatedMist), mist: estimatedMist.toString(), mode, chunks: chunkCount }));
    }

    async function refreshPreparePreview() {
      const file = $("file-input").files?.[0];
      state.preparedUpload = null;
      if (!file) { setComp(t("comp_idle")); setGas(t("gas_idle")); clearManualCompression(); return; }

      try {
        syncCompressionLinkedFields();
        setComp(t("comp_calculating"));
        const draft = await buildDraftEstimate();
        updatePreparedInfo(draft);
      } catch (err) {
        setComp(t("comp_failed", { error: err.message }));
        setGas(t("gas_unavailable", { error: err.message }));
      }
    }

    async function applyManualCompression() {
      const file = $("file-input").files?.[0];
      if (!file) { logKey("err_choose_image"); return; }

      const btn = $("btn-compress");
      btn.disabled = true;
      btn.textContent = t("btn_compressing");
      try {
        const mode = state.compressionControl;
        let result = null;
        const hasTarget = !!String($("compress-target-sui").value || "").trim();
        if (mode === "target" && hasTarget) {
          const targetMist = parseSuiToMist($("compress-target-sui").value);
          if (!targetMist || targetMist <= 0n) throw new Error(t("err_compress_target_invalid"));
          result = await compressWithTargetSui(file, targetMist);
        } else {
          const factor = Number($("compress-factor").value);
          if (!(factor >= 1.05)) throw new Error(t("err_compress_factor_invalid"));
          result = await compressWithFactor(file, factor);
        }

        if (result.isOriginal) {
          clearManualCompression();
          setCompressionResultMeta(t("compress_result_info", {
            width: result.width || "-",
            height: result.height || "-",
            size: fmtBytes(result.bytes?.length || file.size),
          }));
          logKey("log_compression_keep_original", { name: short(file.name) });
        } else {
          if (result.bytes.length > CONFIG.MAX_IMAGE_BYTES) {
            throw new Error(t("err_compress_too_large", { size: result.bytes.length, max: CONFIG.MAX_IMAGE_BYTES }));
          }
          state.manualCompression = {
            sourceKey: fileKey(file),
            bytes: result.bytes,
            mimeType: result.mimeType,
            mode: result.mode,
            width: result.width || 0,
            height: result.height || 0,
          };
          setCompressedPreview(result.bytes, result.mimeType, result.mode);
          setCompressionResultMeta(t("compress_result_info", {
            width: result.width || "-",
            height: result.height || "-",
            size: fmtBytes(result.bytes.length),
          }));
          $("btn-cancel-compress").classList.remove("hidden");
          logKey("log_compression_applied", { mode: result.mode, from: file.size, to: result.bytes.length });
        }

        await refreshPreparePreview();
      } catch (err) {
        log(`壓縮失敗: ${err.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = t("btn_compress");
      }
    }

    async function assertPackageOnCurrentNetwork() {
      const res = await state.client.getObject({ id: state.packageId, options: { showType: true } });
      const type = res?.data?.type;
      if (type !== "package") {
        const net = chainToNetwork(state.chain);
        throw new Error(`目前網路 ${net} 查不到 Package ID：${state.packageId}`);
      }
    }

    async function assertGasBalance() {
      const bal = await state.client.getBalance({ owner: state.address, coinType: "0x2::sui::SUI" });
      const mist = toBigInt(bal?.totalBalance || "0");
      if (mist < BigInt(CONFIG.MIN_BALANCE_MIST)) throw new Error(`SUI 餘額不足，至少需要 ${fmtSui(CONFIG.MIN_BALANCE_MIST)} SUI`);
    }

    async function connect(type) {
      try {
        log(`開始連接 ${type} 錢包...`);
        if (type === "okx") {
          await connectOkxDedicated();
        } else {
          let wallet = null;
          const wallets = walletRegistry.get();
          wallet =
            wallets.find((w) => (w.name || "").toLowerCase().includes("slush")) ||
            wallets.find((w) => (w.name || "").toLowerCase().includes("suiet")) ||
            wallets.find((w) => (w.name || "").toLowerCase().includes("sui wallet")) ||
            wallets.find((w) => (w.name || "").toLowerCase().includes("sui")) ||
            null;
          if (!wallet) throw new Error(`Cannot find ${type} wallet from wallet-standard registry`);

          let account = null;
          if (wallet.features?.["standard:connect"]) {
            const res = await wallet.features["standard:connect"].connect();
            account = res.accounts?.[0] || null;
            state.wallet = wallet;
            state.account = account;
            state.okxSui = null;
            state.address = account?.address || null;
            state.chain = account?.chains?.[0] || CONFIG.TARGET_CHAIN;
            state.walletType = type;
          } else {
            if (typeof wallet.connect === "function") await wallet.connect();
            const accounts = typeof wallet.getAccounts === "function" ? await wallet.getAccounts() : await wallet.requestAccounts();
            const first = accounts?.[0];
            const address = typeof first === "string" ? first : first?.address;
            if (!address) throw new Error("錢包沒有回傳帳號");
            state.wallet = wallet;
            state.account = null;
            state.okxSui = null;
            state.address = address;
            state.chain = CONFIG.TARGET_CHAIN;
            state.walletType = type;
          }
        }

        state.chain = CONFIG.TARGET_CHAIN;
        state.client = new SuiClient({ url: getFullnodeUrl(CONFIG.TARGET_NETWORK) });

        $("connect-ui").classList.add("hidden");
        $("app-ui").classList.remove("hidden");
        $("btn-disconnect").classList.remove("hidden");
        $("address").textContent = t("address_line", { address: state.address });
        $("chain").textContent = t("chain_forced", { chain: state.chain, network: CONFIG.TARGET_NETWORK });
        $("package-id-input").value = state.packageId;

        await assertPackageOnCurrentNetwork();
        await assertGasBalance();
        if (type === "okx") await switchToSuiMainnet();
        log(`錢包已連線 ${short(state.address)}，環境檢查通過`);
        if ($("file-input").files?.[0]) await refreshPreparePreview();
        else {
          setGas(t("gas_idle"));
          setComp(t("comp_idle"));
        }
        setProg(t("progress_idle"));
        await loadGallery();
      } catch (err) {
        log(`連線失敗: ${err.message}`);
      }
    }

    async function walletSignAndExecute(txb) {
      if (state.walletType === "okx") await switchToSuiMainnet();
      if (state.walletType === "okx") {
        const okxSui = state.okxSui || globalThis.okxwallet?.sui;
        if (!okxSui) throw new Error(t("err_okx_provider_unavailable"));
        if (typeof okxSui.signAndExecuteTransactionBlock === "function") {
          try {
            return await okxSui.signAndExecuteTransactionBlock({
              transactionBlock: txb,
              chain: CONFIG.TARGET_CHAIN,
              options: { showEffects: true, showObjectChanges: true, showEvents: true },
            });
          } catch {
            return await okxSui.signAndExecuteTransactionBlock({
              transactionBlock: txb,
              options: { showEffects: true, showObjectChanges: true, showEvents: true },
            });
          }
        }
        throw new Error(t("err_okx_sdk_no_sign_execute"));
      }

      const wallet = state.wallet;
      if (wallet?.features?.["sui:signAndExecuteTransactionBlock"] && state.account) {
        return wallet.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock({
          account: state.account,
          chain: CONFIG.TARGET_CHAIN,
          transactionBlock: txb,
          options: { showEffects: true, showObjectChanges: true, showEvents: true },
        });
      }
      if (typeof wallet?.signAndExecuteTransactionBlock === "function") {
        return wallet.signAndExecuteTransactionBlock({
          chain: CONFIG.TARGET_CHAIN,
          transactionBlock: txb,
          options: { showEffects: true, showObjectChanges: true, showEvents: true },
        });
      }
      if (typeof wallet?.signTransactionBlock === "function") {
        const signed = await wallet.signTransactionBlock({ chain: CONFIG.TARGET_CHAIN, transactionBlock: txb });
        try {
          return await state.client.executeTransactionBlock({
            transactionBlock: signed.transactionBlockBytes,
            signatures: [signed.signature],
            options: { showEffects: true, showObjectChanges: true, showEvents: true },
          });
        } catch {
          return await state.client.executeTransactionBlock({
            transactionBlock: signed.transactionBlockBytes,
            signature: signed.signature,
            options: { showEffects: true, showObjectChanges: true, showEvents: true },
          });
        }
      }
      throw new Error("此錢包不支援 Sui 簽名 API");
    }

    async function executeTx(txb, label, trackUploadGas = false, gasBudgetMist = CONFIG.GAS_BUDGET_APPEND_MIST) {
      txb.setSender(state.address);
      txb.setGasBudget(gasBudgetMist);
      const result = await walletSignAndExecute(txb);
      const status = result?.effects?.status?.status;
      if (status !== "success") {
        const err = result?.effects?.status?.error || "Transaction failed";
        throw new Error(`${label} 失敗: ${err} (gas_budget=${gasBudgetMist})`);
      }
      const gasMist = netGas(result?.effects?.gasUsed);
      if (trackUploadGas) {
        state.currentUploadGasMist += gasMist;
        setGas(`GAS: 累計 ${fmtSui(state.currentUploadGasMist)} SUI (${state.currentUploadGasMist.toString()} MIST)`);
      }
      log(`${label} 成功 (gas ${fmtSui(gasMist)} SUI)`);
      return result;
    }

    function findCreatedObjectId(result, type) {
      const changes = result?.objectChanges || [];
      const hit = changes.find((c) => c.type === "created" && c.objectType === type);
      return hit?.objectId || null;
    }

    async function uploadImageDirect(prepared) {
      const txb = new TransactionBlock();
      const [img] = prepared.isEncrypted
        ? txb.moveCall({
            target: target("upload_image_encrypted"),
            arguments: [
              txb.pure(Array.from(prepared.bytes), "vector<u8>"),
              txb.pure(prepared.mimeType),
              txb.pure(prepared.description),
              txb.pure(prepared.kdfSalt, "vector<u8>"),
              txb.pure(prepared.kdfRounds),
              txb.pure(prepared.nonce, "vector<u8>"),
            ],
          })
        : txb.moveCall({
            target: target("upload_image"),
            arguments: [
              txb.pure(Array.from(prepared.bytes), "vector<u8>"),
              txb.pure(prepared.mimeType),
              txb.pure(prepared.description),
            ],
          });

      txb.transferObjects([img], txb.pure(state.address));
      const result = await executeTx(txb, "單筆直傳上傳", true, CONFIG.GAS_BUDGET_DIRECT_MIST);
      const type = `${state.packageId}::${CONFIG.MODULE_NAME}::Image`;
      return findCreatedObjectId(result, type);
    }

    async function startUploadSession(prepared) {
      const txb = new TransactionBlock();
      const [session] = txb.moveCall({
        target: target("start_upload"),
        arguments: [
          txb.pure(prepared.mimeType),
          txb.pure(prepared.description),
          txb.pure(prepared.isEncrypted),
          txb.pure(prepared.kdfSalt, "vector<u8>"),
          txb.pure(prepared.kdfRounds),
          txb.pure(prepared.nonce, "vector<u8>"),
        ],
      });
      txb.transferObjects([session], txb.pure(state.address));
      const result = await executeTx(txb, "建立上傳會話", true, CONFIG.GAS_BUDGET_START_MIST);
      const type = `${state.packageId}::${CONFIG.MODULE_NAME}::UploadSession`;
      const id = findCreatedObjectId(result, type);
      if (!id) throw new Error("Cannot find UploadSession ID. Check contract deployment and package ID.");
      return id;
    }

    async function appendChunkBatch(sessionId, chunks, batchIndex, totalBatches, doneCount, totalChunks) {
      const txb = new TransactionBlock();
      for (const chunk of chunks) {
        txb.moveCall({ target: target("append_chunk"), arguments: [txb.object(sessionId), txb.pure(chunk, "vector<u8>")] });
      }
      await executeTx(txb, `上傳批次 ${batchIndex}/${totalBatches} (${doneCount}/${totalChunks})`, true, CONFIG.GAS_BUDGET_APPEND_MIST);
    }

    async function finalizeUpload(sessionId) {
      const txb = new TransactionBlock();
      const [img] = txb.moveCall({ target: target("finalize_upload"), arguments: [txb.object(sessionId)] });
      txb.transferObjects([img], txb.pure(state.address));
      const result = await executeTx(txb, "完成上傳", true, CONFIG.GAS_BUDGET_FINALIZE_MIST);
      const type = `${state.packageId}::${CONFIG.MODULE_NAME}::Image`;
      return findCreatedObjectId(result, type);
    }

    async function cancelUploadSession(sessionId) {
      const txb = new TransactionBlock();
      txb.moveCall({ target: target("cancel_upload"), arguments: [txb.object(sessionId)] });
      await executeTx(txb, "取消失敗上傳會話", false, CONFIG.GAS_BUDGET_CANCEL_MIST);
    }

    async function handleUpload() {
      if (!isConnected()) { log("請先連接錢包"); setProg("上傳進度: 失敗 (請先連接錢包)"); return; }
      const btn = $("btn-upload");
      btn.disabled = true;
      btn.textContent = t("btn_uploading");
      let sessionId = null;

      try {
        if (state.walletType === "okx") await switchToSuiMainnet();
        await assertPackageOnCurrentNetwork();
        await assertGasBalance();
        setProg("上傳進度: 準備上傳資料...");

        const prepared = await prepareUploadFromUI();
        state.preparedUpload = prepared;
        updatePreparedInfo(prepared);
        log(`準備上傳 bytes=${prepared.uploadBytes}, chunks=${prepared.chunks.length}, encrypted=${prepared.isEncrypted}`);

        state.currentUploadGasMist = 0n;
        setGas("GAS: 計算中...");

        let imageId = null;
        let usedDirect = false;
        if (prepared.chunks.length === 1) {
          try {
            usedDirect = true;
            setProg("上傳進度: 單筆直傳中...");
            imageId = await uploadImageDirect(prepared);
          } catch (err) {
            usedDirect = false;
            log(`單筆直傳失敗，回退分塊流程: ${err.message}`);
          }
        }

        if (!usedDirect) {
          sessionId = await startUploadSession(prepared);
          setProg(`上傳進度: 已建立會話 ${short(sessionId)}`);

          const total = prepared.chunks.length;
          const totalBatches = Math.ceil(total / CONFIG.CHUNKS_PER_TX);
          for (let i = 0; i < total; i += CONFIG.CHUNKS_PER_TX) {
            const batch = prepared.chunks.slice(i, i + CONFIG.CHUNKS_PER_TX);
            const batchIndex = Math.floor(i / CONFIG.CHUNKS_PER_TX) + 1;
            const done = Math.min(i + batch.length, total);
            await appendChunkBatch(sessionId, batch, batchIndex, totalBatches, done, total);
            setProg(`上傳進度: ${done}/${total} chunks (${Math.floor((done * 100) / total)}%)`);
          }

          imageId = await finalizeUpload(sessionId);
        }

        setProg(`上傳進度: 完成，Image ID = ${imageId || "(請看下方清單)"}`);
        log(`上傳完成，總 GAS ${fmtSui(state.currentUploadGasMist)} SUI`);
        log(`上傳成功，總 GAS: ${fmtSui(state.currentUploadGasMist)} SUI`);

        $("file-input").value = "";
        $("password-input").value = "";
        clearManualCompression();
        state.preparedUpload = null;
        setComp(t("comp_idle"));
        await loadGallery();
      } catch (err) {
        log(`上傳失敗: ${err.message}`);
        setProg(`上傳進度: 失敗 (${err.message})`);
        if (sessionId) {
          try { await cancelUploadSession(sessionId); } catch (e) { log(`清理會話失敗: ${e.message}`); }
        }
      } finally {
        btn.disabled = false;
        btn.textContent = t("btn_upload");
      }
    }

    async function deleteImage(objectId) {
      const txb = new TransactionBlock();
      txb.moveCall({ target: target("delete_image"), arguments: [txb.object(objectId)] });
      const result = await executeTx(txb, `刪除圖片 ${short(objectId)}`, false, CONFIG.GAS_BUDGET_DELETE_MIST);
      const gasUsed = result?.effects?.gasUsed || {};
      const rebateMist = toBigInt(gasUsed.storageRebate);
      log(`刪除返還 SUI: ${fmtSui(rebateMist)} (storage rebate, ${rebateMist.toString()} MIST)`);
    }

    async function applyPackageId() {
      const value = $("package-id-input").value.trim();
      if (!value) { log("Package ID 不能為空"); return; }
      state.packageId = value;
      localStorage.setItem("sui_image_pkg", value);
      log(`已更新 Package ID: ${value}`);
      if (!isConnected()) return;
      try {
        await assertPackageOnCurrentNetwork();
        await loadGallery();
        log("Package ID 套用成功");
      } catch (err) {
        log(`Package 驗證失敗: ${err.message}`);
      }
    }

    async function decryptImageFields(fields, password) {
      const cipher = new Uint8Array(b(fields.data));
      const salt = new Uint8Array(b(fields.kdf_salt));
      const nonce = new Uint8Array(b(fields.nonce));
      const rounds = Number(fields.kdf_rounds || 0);
      if (!rounds || rounds < 1) throw new Error("Invalid encryption metadata on chain");
      return decryptBytes(cipher, password, salt, nonce, rounds);
    }

    function renderImageBlobInto(previewEl, bytes, mimeType) {
      previewEl.innerHTML = "";
      const blob = new Blob([bytes], { type: mimeType || "image/webp" });
      const url = URL.createObjectURL(blob);
      const img = document.createElement("img");
      img.src = url;
      img.style.cursor = "zoom-in";
      img.addEventListener("click", () => openLightbox(url));
      previewEl.appendChild(img);
    }

    function createCardSkeleton(objectId, fields) {
      const card = document.createElement("article");
      card.className = "item";
      const desc = fields.description || t("card_no_description");
      const encrypted = !!fields.is_encrypted;
      const chunkCount = fields.chunk_count || "-";
      const size = fmtBytes(fields.size_bytes || b(fields.data).length);
      const uploader = fields.uploader || "";
      card.innerHTML = `
        <div class="preview" data-role="preview">${t("card_loading")}</div>
        <div style="font-weight:700;font-size:13px;">${desc}</div>
        <div class="meta">ID: ${objectId}</div>
        <div class="meta">${t("meta_uploader", { uploader })}</div>
        <div class="meta">${t("meta_size_chunks", { size, chunks: chunkCount })}</div>
        <div class="meta">${encrypted ? t("meta_encrypted_hint") : t("meta_public_hint")}</div>
        <div class="actions" data-role="actions"></div>
      `;
      return card;
    }

    function addCommonActions(card, objectId, fields, isOwner) {
      const actions = card.querySelector('[data-role="actions"]');

      const btnCopy = document.createElement("button");
      btnCopy.className = "btn";
      btnCopy.textContent = t("btn_copy_id");
      btnCopy.onclick = async () => {
        await navigator.clipboard.writeText(objectId);
        log(`已複製 ID: ${objectId}`);
      };
      actions.appendChild(btnCopy);

      if (isOwner) {
        const btnDel = document.createElement("button");
        btnDel.className = "btn btn-danger";
        btnDel.textContent = t("btn_delete");
        btnDel.onclick = async () => {
          log(`刪除圖片中: ${short(objectId)}`);
          try { await deleteImage(objectId); await loadGallery(); } catch (err) { log(`刪除失敗: ${err.message}`); }
        };
        actions.appendChild(btnDel);
      }

      const btnDownload = document.createElement("button");
      btnDownload.className = "btn btn-secondary";
      btnDownload.textContent = t("btn_download");
      btnDownload.onclick = async () => {
        try {
          let bytes;
          if (fields.is_encrypted) {
            const cardPwd = card.querySelector('[data-role="pwd"]')?.value || $("lookup-password").value || $("password-input").value;
            if (!cardPwd) {
              log(`下載失敗: ${short(objectId)} 為加密圖片，請先輸入密碼`);
              return;
            }
            bytes = await decryptImageFields(fields, cardPwd);
          } else {
            bytes = new Uint8Array(b(fields.data));
          }
          const mimeType = fields.mime_type || "application/octet-stream";
          const blob = new Blob([bytes], { type: mimeType });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          const ext = mimeType.includes("/") ? mimeType.split("/")[1] : "bin";
          a.download = `${objectId}.${ext}`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          log(`已下載圖片: ${short(objectId)}`);
        } catch (err) {
          log(`下載失敗: ${err.message}`);
        }
      };
      actions.appendChild(btnDownload);
    }

    function renderPublicPreview(card, fields) {
      const preview = card.querySelector('[data-role="preview"]');
      renderImageBlobInto(preview, new Uint8Array(b(fields.data)), fields.mime_type || "image/webp");
    }

    function renderEncryptedPreview(card, fields, autoPassword = "") {
      const preview = card.querySelector('[data-role="preview"]');
      preview.innerHTML = `
        <div style="width:100%;display:grid;gap:6px;">
          <div>${t("enc_locked_message")}</div>
          <input class="input" type="password" placeholder="${t("enc_input_placeholder")}" data-role="pwd" />
          <button class="btn btn-ok" data-role="unlock">${t("btn_unlock")}</button>
          <div class="meta" data-role="err"></div>
        </div>
      `;
      const pwd = preview.querySelector('[data-role="pwd"]');
      const btn = preview.querySelector('[data-role="unlock"]');
      const errEl = preview.querySelector('[data-role="err"]');
      if (autoPassword) pwd.value = autoPassword;
      btn.onclick = async () => {
        errEl.textContent = "";
        try {
          if (!pwd.value) throw new Error(t("err_enter_password"));
          const plain = await decryptImageFields(fields, pwd.value);
          renderImageBlobInto(preview, plain, fields.mime_type || "image/webp");
        } catch (err) {
          errEl.textContent = tl(err.message);
          errEl.style.color = "#f87171";
        }
      };
      if (autoPassword) btn.click();
    }

    function renderImageCard(container, objectId, fields, options = {}) {
      const owner = (fields.uploader || "").toLowerCase() === (state.address || "").toLowerCase();
      const card = createCardSkeleton(objectId, fields);
      addCommonActions(card, objectId, fields, owner && options.allowDelete !== false);
      if (fields.is_encrypted) renderEncryptedPreview(card, fields, options.autoPassword || "");
      else renderPublicPreview(card, fields);
      container.appendChild(card);
    }

    function parseImageFieldsFromObject(data) {
      const type = data?.type || data?.content?.type;
      if (!type || !type.endsWith(`::${CONFIG.MODULE_NAME}::Image`)) throw new Error("這不是 Image 物件");
      const fields = data?.content?.fields;
      if (!fields) throw new Error("Object fields are missing");
      return fields;
    }

    async function loadGallery() {
      const el = $("gallery");
      el.innerHTML = "";
      if (!state.address) return;
      try {
        const res = await state.client.getOwnedObjects({
          owner: state.address,
          filter: { StructType: `${state.packageId}::${CONFIG.MODULE_NAME}::Image` },
          options: { showType: true, showContent: true },
        });
        if (!res.data.length) { el.innerHTML = `<p class="meta">${t("gallery_empty")}</p>`; return; }
        for (const row of res.data) {
          const objectId = row?.data?.objectId;
          const fields = row?.data?.content?.fields;
          if (!objectId || !fields) continue;
          renderImageCard(el, objectId, fields, { allowDelete: true });
        }
        logKey("log_loaded_owned_images", { count: res.data.length });
      } catch (err) {
        el.innerHTML = `<p class="meta">${tl(`載入失敗: ${err.message}`)}</p>`;
      }
    }

    async function lookupById() {
      const id = $("lookup-id").value.trim();
      const pwd = $("lookup-password").value;
      const viewer = $("id-viewer");
      viewer.innerHTML = "";
      if (!id) { logKey("err_enter_object_id"); return; }
      try {
        const res = await state.client.getObject({ id, options: { showType: true, showContent: true } });
        if (!res?.data) throw new Error(t("err_object_id_not_found"));
        const fields = parseImageFieldsFromObject(res.data);
        renderImageCard(viewer, res.data.objectId, fields, { allowDelete: false, autoPassword: pwd });
        log(`已載入 ID ${id}`);
      } catch (err) {
        viewer.innerHTML = `<p class="meta">${tl(`查詢失敗: ${err.message}`)}</p>`;
      }
    }

    function bindEvents() {
      $("lang-select").addEventListener("change", (e) => {
        state.lang = e.target.value;
        applyLanguage();
        $("id-viewer").innerHTML = "";
        loadGallery();
      });
      $("btn-slush").addEventListener("click", () => connect("slush"));
      $("btn-okx").addEventListener("click", () => connect("okx"));
      $("btn-upload").addEventListener("click", handleUpload);
      $("btn-refresh").addEventListener("click", loadGallery);
      $("btn-lookup").addEventListener("click", lookupById);
      $("btn-apply-package").addEventListener("click", applyPackageId);
      $("btn-disconnect").addEventListener("click", disconnectWallet);
      $("btn-compress").addEventListener("click", applyManualCompression);
      $("compress-preview").addEventListener("click", () => {
        if (!state.compressionPreviewUrl) return;
        toggleLightbox(state.compressionPreviewUrl);
      });
      $("compress-lightbox").addEventListener("click", () => toggleLightbox(state.compressionPreviewUrl));
      $("btn-cancel-compress").addEventListener("click", async () => {
        clearManualCompression();
        logKey("log_compression_canceled");
        await refreshPreparePreview();
      });
      $("file-input").addEventListener("change", async () => {
        clearManualCompression();
        state.compressionControl = "factor";
        await refreshPreparePreview();
      });
      $("compress-factor").addEventListener("input", async () => {
        state.compressionControl = "factor";
        syncTargetFromFactor();
        await refreshPreparePreview();
      });
      $("compress-target-sui").addEventListener("input", async () => {
        state.compressionControl = "target";
        syncFactorFromTarget();
        await refreshPreparePreview();
      });
      $("description-input").addEventListener("input", refreshPreparePreview);
      $("password-toggle").addEventListener("change", () => {
        const enabled = $("password-toggle").checked;
        $("password-input").disabled = !enabled;
        if (!enabled) $("password-input").value = "";
        refreshPreparePreview();
      });
      $("password-input").addEventListener("input", refreshPreparePreview);
      $("compress-factor").addEventListener("keydown", (e) => { if (e.key === "Enter") applyManualCompression(); });
      $("compress-target-sui").addEventListener("keydown", (e) => { if (e.key === "Enter") applyManualCompression(); });
    }

    bindEvents();
    $("lang-select").value = I18N[state.lang] ? state.lang : "zh-Hant";
    applyLanguage();
    $("package-id-input").value = state.packageId;
    resetUiAfterDisconnect();
    state.logRows = [];
    logKey("log_booting");
    logKey("ready_hint");
  </script>
</body>
</html>
